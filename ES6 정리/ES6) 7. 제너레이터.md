## 7. 제너레이터

제너레이터는 **함수의 실행을 중간에 멈추고 재개**할 수 있는 기능이다.

실행을 멈출 때 값을 전달할 수 있기 때문에, 반복문에서 제너레이터가 전달하는 값을 하나씩 꺼내서 사용할 수 있다. 이는 배열이 반복문에서 사용되는 방식과 같다.

다만, 제너레이터는 **보통의 컬렉션과 달리 값을 미리 많들어 놓지 않는다.**  값을 미리 만들어 놓으면 불필요하게 메모리를 사용하는 단점이 있다. 제너레이터를 사용하면 **필요한 순간에 값을 계산해서 전달**할 수 있기 때문에 **메모리 측면에서 효율적**이다.

제너레이터는 값을 전달하는 용도 외에도 **다른 함수와 협업 멀티태스킹을 할 수 있다.** 실행을 멈추고 재개할 수 있기 때문에 멀티태스킹이 가능하다.

### ◆ 제너레이터 이해하기

제너레이터는 (*)와 함께 정의된 함수, 함수가 반환하는 제너레이터 객체로 구성된다.

```js
function* f1(){ // 별표와 함께 정의된 함수는 제너레이터 함수이다.
	yield 10; // yield 키워드를 사용하면 함수의 실행을 멈출 수 있다.
    yield 20;
    return 'finished';
}
const gen = f1(); // 제너레이터를 실행하면 제너레이터 객체가 반환된다.
```

제너레이터 객체는 `next`, `return`, `throw` 메서드를 갖고 있다. 우리는 주로 `next` 메서드를 사용하게 된다. 제너레이터 객체가 `next` 메서드를 갖고 있다는 것은 **반복자(iterator)**라는 것을 암시한다.

```js
function* f1(){
    console.log('f1-1');
    yield 10;
    console.log('f1-2');
    yield 20;
    console.log('f1-2');
    return 'finished';
}

const gen = f1(); // 제너레이터 함수를 실행하면 제너레이터 객체만 반환되고, 함수 내부 코드는 실행되지 않는다.
console.log(gen.next()); // next 메서드를 호출하면 yield를 만날 때까지 실행되고 데이터 객체를 반환한다. yield를 만나면 done 속성값은 false가 되고, 만나지 못하면 true이다. yield 오른쪽의 값이 데이터 객체의 value 속성값으로 넘어온다.
console.log(gen.next());
console.log(gen.next()); // 더는 yield를 만나지 못했기 때문에 done 속성은 true가 된다. 만약 return이 함수의 최상단에 있었다면 첫 번째 next 호출에서 done은 true가 된다.


// f1-1
// { value: 10, done: false }
// f1-2
// { value: 20, done: false }
// f1-3
// { value: 'finished', done: true }
```

 다음은 `throw`이다.

```js
function* f1(){
  try{
    console.log('f1-1');
    yield 10;
    console.log('f1-2');
    yield 20;
  }
  catch(err){
    console.log('f1-catch', err);
  }
  
}

const gen = f1();
console.log(gen.next());
console.log(gen.throw('error !!')); // throw를 호출하면 예외가 발생한 것으로 처리하기 때문에 catch 문으로 들어간다. 이때 데이터 객체의 done은 true가 된다.

// f1-1
// { value: 10, done: false }
// f1-catch error !!
// { value: undefined, done: true }
```

---



### ◆ 반복 가능하면서 반복자이다.

제너레이터 객체는 반복 가능하면서 반복자이다.

- 반복자 객체의 조건
  - `next` 메서드를 갖고있다.
  - `next` 메서드는 `value`와 `done` 속성값을 가진 객체를 반환한다.
  - `done` 속성값은 작업이 끝났을 때 참이 된다.

여기까지는 앞에서 확인할 수 있다.

- 반복 가능(iterable)한 객체의 조건

  - `Symbol.iterator` 속성값으로 함수를 가지고 있다.
  - 해당 함수를 호출하면서 반복자를 반환한다.

  > **배열은 대표적인 반복 가능한 객체**이다.
  >
  > ```js
  > const arr = [10, 20, 30];
  > const iter = arr[Symbol.iterator](); // 배열은 Symbol.iterator 속성값으로 함수를 갖고 있고,
  > console.log(iter.next());  // 반환한 값이 반복자이다.
  > 
  > // {value: 10, done: false}
  > ```

다음은 제너레이터 객체가 반복 가능한 객체임을 보여준다.

```js
function* f1 () {
	return 'finished';
}

const gen = f1();
console.log(gen[Symbol.iterator]() === gen); // true
// Symbol.iterator 속성값을 호출한 결과가 자기 자신(반복자)이다.
```

반복 가능한 객체는 밑에와 같이 `for of` 문과 전개 연산자에서 유용하게 쓰인다.