## 1. `const`, `let`

ES5까지 `var`를 이용해서 변수를 정의했고 유일한 방법이었다. `const`와 `let`은 `var`가 안고 있는 문제들을 해결하기위해 나왔다.

---



### ◆ `var`의 문제

#### 1. 함수 스코프

**스코프**란 변수가 사용될 수 있는 영역을 말한다. `var`는 함수 스코프이기에, 함수를 벗어난 영역에서 사용하면 에러가 발생한다.

```js
// 함수를 벗어나면 사용할 수 없다.
function exam() {
	var i = 1;
}

console.log(i) // 참조 에러
```

`var`를 함수가 아닌 **프로그램의 가장 바깥에 정의하면 전역 변수**가 되는데, 이는 **프로그램 전체를 감싸는 하나의 함수**가 있다고 생각하면 이해하기 쉽다.

특이한 점은 **함수 안에서 `var` 키워드를 사용하지 않고 변수를 선언**하면, 그 변수는 **전역 변수**가 된다.

```js
// 특이한 점
function exam1() {
    i = 1; // var 키워드 없이 선언하여 전역변수가 됨.
}
function exam2() {
    console.log(i);
}
exam1();
exam2(); // 1 출력
```

또한, 함수 스코프이기 때문에 **for 반복문에서 정의된 변수가 반복문이 끝난 이후에도 계속 남는 문제점**이 있다. while, switch, if 문 에서도 마찬가지이다.

```js
// 반복문에서 벗어나도 변수가 사라지지 않는다.
for(var i = 0; i < 10; i++){
    console.log(i);
}
console.log(i); // 10 출력
```

>  `var` 변수의 스코프를 제한하기위해 **'즉시 실행 함수'**를 사용하기도 한다. 즉시 실행 함수는 정의한 시점에서 바로 실행되고 사라지기 때문에 `var`를 즉시 실행 함수로 묶으면 스코프를 제한할 수 있다.
>
>  하지만, 작성하기 **번거롭고 가독성도 떨어져서** 근본적인 해결책이 될 수는 없다.



#### 2. `var`의 호이스팅

`var`로 정의된 변수는 그 **변수가 속한 스코프의 최상단으로 끌어올려진다**. 이를 **호이스팅(hoisting)**이라고 부른다.

```js
// 정의된 시점보다 먼저 변수를 사용해도 에러가 나지 않는다.
console.log(myVar); // undefined 출력 
var myVar = 1;
```

위의 코드에서, 변수를 정의하기 전에 사용했음에도 에러가 발생하지 않는다. 게다가 제대로 작동하지도 않는다. (1이 아니라 undefined를 출력한다.)

이것은 해당 **변수의 정의가 위쪽으로 끌어올려졌기 때문**인데, 밑의 코드처럼 변경됐다고 생각하면 쉽다.

```js
var myVar = undefined;
console.log(myVar);
myVar = 1;
```

변수의 정의만 끌어올려지고, 값은 원래 정의한 위치에서 할당된다. 밑의 코드처럼 변수가 정의된 곳에서 값을 할당 할 수도 있다.

```js
console.log(myVar); // undefined 출력
myVar = 2;
console.log(myVar); // 2 출력
var myVar = 1;
```

**버그 같은데 에러 없이 사용될 수 있다는 점이 단점**이다. 호이스팅은 직관적이지 않으며, 보통의 프로그래밍 언어에서는 찾아보기 힘든 성질이다.



#### 3. 기타 문제들

- **한 번 정의된 변수를 재정의할 수 있다.**

  - ```js
    var myVar = 1;
    var myVar = 2; // 변수 재정의가 가능하다.
    ```

  - 변수를 정의 한다는 것은, 이전에 없던 변수를 생성한다는 의미로 통용된다. 따라서 위의 코드가 에러 없이 사용될 수 있다는 것은 **직관적이지도 않고, 자칫하면 버그**로 이어질 수 있다.  (코드가 길어져서 이전에 선언한 변수를 까먹고 같은 이름으로 새로 생성한다고 했을 때, 서비스 장애로 이어진다.)

- **`var`는 재할당 가능한 변수로밖에 만들 수 없다.**

  - 상수처럼 써야하는 경우에도 재할당 가능한 변수로 만들어야한다. 안정적인 면에서 매우 위험하다.

---



### ◆ `const`, `let`으로 해결

#### 1. 블록 스코프

블록 스코프는 대부분의 언어에서 사용하므로 개발자에게 익숙한 개념이다.

```js
if(true){
	const i = 0;
}
console.log(i); // 참조 에러
```

위와 같은 상황에서 에러가 발생하는 것이 **직관적이며, 이해하기도 쉽다**. 

`var`를 사용한다면, if 문 안에서 생성된 변수가 밖에서도 계속 살아있기 때문에, 함수 스코프를 벗어나기 전까지 신경 써서 관리해야 했다.

```js
// 같은 이름을 갖는 변수의 사용 예
let foo = 'bar1';
console.log(foo); // bar1 출력
if(true){
    let foo = 'bar2';
    console.log(foo); // bar2 출력
}
console.log(foo); // bar1 출력
```



#### 2. `const`, `let`의 호이스팅

`const`, `let`도 호이스팅된다. 하지만, `var`와는 다르게 **정의하기 전에 사용하면 참조 에러**가 발생한다.

```js
console.log(foo); // 참조 에러
const foo = 1;
```

> 위와 같은 상황때문에 `const`, `let`은 호이스팅이 되지 않는다고 생각하기 쉽지만, 실제로는 호이스팅이 된다.
>
> 다만, 변수가 **정의된 위치와 호이스팅된 위치 사이에서 변수를 사용하려고 하면 에러가 발생**한다. 이 구간을 **임시적 사각지대 (temporal dead zone)**라고 한다.
>
> ```js
> const foo = 1; // 1번 변수
> {
>  // 호이스팅된 위치는 변수가 속한 스코프의 최상단이다. 
>  // 여기부터, 변수가 정의되는 위치 이전까지, 임시적 사각지대라고 보면 된다.
> 	console.log(foo); // 참조 에러
> 	const foo = 2; // 2번 변수
> }
> ```
>
> 만약 2번 변수가 호이스팅되지 않았다면, 참조 에러는 발생하지 않고, 1번 변수가 출력될 것이다.
>
> 2번 변수의 호이스팅 때문에, console.log 안의 변수는 2번 변수를 참조하게 된다.
> 그리고 console.log()가 임시적 사각지대 안에 있기 때문에 에러가 발생한다.
>
> `var`는 임시적 사각지대가 없다.



#### 3. `const`는 변수를 재할당 불가능하게 만든다

재할당이 불가능한 변수는 프로그램의 복잡도를 상당히 낮춰주기 때문에 되도록이면 재할당 불가능한 변수를 사용하는 게 좋다.

`const` 변수는 **재할당이 불가능**하다. 상수처럼 사용할 수 있다. **재할당 시 에러**가 발생한다. 재할당이 가능하게 할려면 `let`을 사용하면된다. 또한, `const`는 무조건 초기화를 해주어야 한다.

다만, `const`로 정의된 **객체는 내부 속성값은 수정, 추가가 가능**하다. java의 `final`, 다른 언어의 `const`와 같은 방식으로 동작한다.

> 객체 내부의 속성값도 수정 불가능하게 만들고 싶다면 immer, immutable.js 등 외부 패키지를 활용하는 것이 좋다.
>
> 외부 패키지는 객체를 수정하려고 할 때 기존 객체는 변경하지 않고, 새로운 객체를 생성한다.
>
> 새로운 객체를 생성하는 편의 기능이 필요없고, 단지 수정 불가만 하고 싶다면, js 내장 함수를 사용하면 된다.
>
> - Object.preventExtensions
> - Object.seal
> - Object.freeze

---

